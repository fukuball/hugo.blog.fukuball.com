


  




  


  

<!DOCTYPE html>
<html lang="en-us">
  <head>
    
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Hugo 0.48 with theme Tranquilpeak 0.4.3-BETA">
    <title>Posts</title>
    <meta name="author" content="Fukuball">
    <meta name="keywords" content="">

    <link rel="icon" href="images/favicon.ico">
    
      <link rel="alternate" type="application/rss+xml" title="RSS" href="https://blog.fukuball.com/post/index.xml">
    

    
    <meta name="description" content="我是林志傑，網路上常用的名字是 Fukuball。我使用 PHP 及 Python，對機器學習及區塊鏈技術感到興趣。 https://www.fukuball.com">
    <meta property="og:description" content="我是林志傑，網路上常用的名字是 Fukuball。我使用 PHP 及 Python，對機器學習及區塊鏈技術感到興趣。 https://www.fukuball.com">
    <meta property="og:type" content="blog">
    <meta property="og:title" content="Posts">
    <meta property="og:url" content="/post/">
    <meta property="og:site_name" content="I am Fukuball">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="I am Fukuball">
    <meta name="twitter:description" content="我是林志傑，網路上常用的名字是 Fukuball。我使用 PHP 及 Python，對機器學習及區塊鏈技術感到興趣。 https://www.fukuball.com">
    
    

    
    

    
      <meta property="og:image" content="//www.gravatar.com/avatar/6c910ba730e0acfda9ee450eec9776e6?s=640">
    

    
    
    

    

    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha256-eZrrJcwDc/3uDhsdt61sL2oOBY362qM3lon1gyExkL0=" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/jquery.fancybox.min.css" integrity="sha256-vuXZ9LGmmwtjqFX1F+EKin1ThZMub58gKULUyf0qECk=" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/helpers/jquery.fancybox-thumbs.min.css" integrity="sha256-SEa4XYAHihTcEP1f5gARTB2K26Uk8PsndQYHQC1f4jU=" crossorigin="anonymous" />
    
    
    <link rel="stylesheet" href="https://blog.fukuball.com/css/style-jsjn0006wyhpyzivf6yceb31gvpjatbcs3qzjvlumobfnugccvobqwxnnaj8.min.css" />
    
    

    
      
    
    
  </head>

  <body>
    <div id="blog">
      <header id="header" data-behavior="1">
  <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
  <div class="header-title">
    <a class="header-title-link" href="https://blog.fukuball.com/">I am Fukuball</a>
  </div>
  
    
      <a class="header-right-picture "
         href="https://blog.fukuball.com/#about">
    
    
    
      
        <img class="header-picture" src="//www.gravatar.com/avatar/6c910ba730e0acfda9ee450eec9776e6?s=90" alt="" />
      
    
    </a>
  
</header>

      <nav id="sidebar" data-behavior="1">
  <div class="sidebar-container">
    
      <div class="sidebar-profile">
        <a href="https://blog.fukuball.com/#about">
          <img class="sidebar-profile-picture" src="//www.gravatar.com/avatar/6c910ba730e0acfda9ee450eec9776e6?s=110" alt="" />
        </a>
        <h4 class="sidebar-profile-name">Fukuball</h4>
        
          <h5 class="sidebar-profile-bio">我是林志傑，網路上常用的名字是 Fukuball。我使用 PHP 及 Python，對機器學習及區塊鏈技術感到興趣。 <a href="https://www.fukuball.com">https://www.fukuball.com</a></h5>
        
      </div>
    
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://blog.fukuball.com/#about">
    
      <i class="sidebar-button-icon fa fa-lg fa-question"></i>
      
      <span class="sidebar-button-desc">About</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://blog.fukuball.com/">
    
      <i class="sidebar-button-icon fa fa-lg fa-home"></i>
      
      <span class="sidebar-button-desc">Home</span>
    </a>
  </li>


    </ul>
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://facebook.com/fukuball" target="_blank" rel="noopener">
    
      <i class="sidebar-button-icon fa fa-lg fa-facebook"></i>
      
      <span class="sidebar-button-desc">Facebook</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://github.com/fukuball" target="_blank" rel="noopener">
    
      <i class="sidebar-button-icon fa fa-lg fa-github"></i>
      
      <span class="sidebar-button-desc">GitHub</span>
    </a>
  </li>


    </ul>
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://blog.fukuball.com/">
    
      <i class="sidebar-button-icon fa fa-lg fa-rss"></i>
      
      <span class="sidebar-button-desc">Blog</span>
    </a>
  </li>


    </ul>
  </div>
</nav>

      

      <div id="main" data-behavior="1"
        class="
               hasCoverMetaIn
               ">
        <section class="postShorten-group main-content-wrap">
          
          
            
  
    
      
        
      
    
  


  

<article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
  <div class="postShorten-wrap">
    
    <div class="postShorten-header">
      <h1 class="postShorten-title" itemprop="headline">
        <a class="link-unstyled" href="https://blog.fukuball.com/ethereum-%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98-14blockchain-%E6%8A%80%E8%A1%93%E5%8E%9F%E7%90%86%E7%B0%A1%E4%BB%8B/">
          Ethereum 開發筆記 1–4：Blockchain 技術原理簡介
        </a>
      </h1>
      
  <div class="postShorten-meta post-meta">
    
      <time itemprop="datePublished" datetime="2018-09-08T15:22:20&#43;08:00">
        
  September 8, 2018

      </time>
    
    
  </div>

    </div>
    <div class="postShorten-excerpt" itemprop="articleBody" style="margin-bottom: 50px;">
      <div class="main-content-wrap">
        

<p>之前我們簡單地介紹過 Blockchain 了，但我們還是對 Blockchain 背後的技術原理不是那麼了解，我們知道 Blockchain 是因為一個數位貨幣帳本這樣的概念被創造出來的，而數位貨幣最擔心的是什麼問題呢？其實就是雙重支付（Double-Spending）這樣的問題。</p>

<p>數位貨幣不像實體貨幣，數位資產比起實體資產容易複製，也因此如果花用數位貨幣的行為如果沒有處理好，就會產生憑空多出其他交易，這就像是偽鈔一樣，會造成通貨膨脹而導致貨幣貶值，讓人不再信任並願意持與流通。因此數位貨幣的支付通常需要一個受信任的第三方來做驗證，這樣的做法雖然簡單，卻存在單點脆弱性，只要這第三方受到攻擊或是監守自盜也一樣會讓這個數位貨幣變成一個失敗的貨幣。</p>

<p>分散式去中心化帳本能解決單點脆弱性的問題，但在驗證正確性這點難度卻很高，所有的節點都有記帳的權利，要如何確定由誰來記帳、記的帳對不對？如果無法確定帳是對的，那就存在雙重支付的風險。</p>

<p>為了改善單點脆弱性及雙重支付這樣的問題，許多分散式的雙重支付防範方法慢慢被提出來，中本聰提出了去中心化（以受信任第三方為中心）的方法來展示解決雙重支付問題，並實作出了 Bitcoin，使用共識機制來解決記帳及驗證的問題，這帶來去中心化數位貨幣帳本的成功。</p>

<p>Bitcoin 的共識協議主要由「工作量證明」（Proof-of-Work, PoW）和「最長鏈機制」兩部分組成，Bitcoin 上的各個節點就是透過共識機制中的工作量證明來決定誰有記帳權，然後取得記帳權的節點就能將新的區塊記帳加到最長鏈上並給予該節點獎勵（新區塊獎勵及交易費收益）。</p>

<p>Bitcoin 的 工作量證明大概會做以下的事情：</p>

<ol>
<li>收集還未記到帳上的交易</li>
<li>檢查每個交易中付款地址有沒有足夠的餘額</li>
<li>驗證交易是否有正確的簽名</li>
<li>把驗證通過的交易信息進行打包（組成 Merkle Tree）</li>
<li>為自己增加一個交易紀錄獲得 Bitcoin 獎勵金</li>
<li>計算合法的 hash 爭奪記帳權</li>
</ol>

<p>計算合法 hash 的方式請見下方影片說明，個人覺得這個影片是目前將 Blockchain 加密機制說明得最清楚的影片。我這邊簡略說明一下，合法的 hash 公式大致看起來像這樣：hash(交易內容+交易簽名+nonce+上一個區塊的 hash)，我們要取得記帳權，就需要找出前面開頭有 N 個 0 的 hash，由於交易內容、交易簽名及上一個區塊的 hash 都是不可變的，所以每個節點就是不斷的調整 nonce 來計算得出不同的 hash，直到找到開頭 N 個 0 的 hash 為止，第一個找的節點就能獲得記帳權，而其他的節點只要計算 hash 對不對就能驗證這個帳對不對。其中 N 個 0 開頭的 hash 就代表了計算的難度，越多 0 代表越難找到這樣的 hash，也因此可以調整計算難度。就是這樣的設計解決了去中心化分散式系統驗證資料及決定記帳順序的難題，也就改善了數位貨幣單點脆弱性及雙重支付的問題。</p>

<iframe style="margin-top: 30px;" width="560" height="315" src="https://www.youtube.com/embed/_160oMzblY8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>

<iframe width="560" height="315" src="https://www.youtube.com/embed/xIDL_akeras" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>

<p>以上的內容看完應該就能大體了解 Blockchain 的原理了，甚至要自己做一個 Blockchain 都沒問題！了解了 Blockchain 的技術原理之後，應該能更信任去中心化的數位貨幣的安全性，或許有天大家都信任了去中心化的數位貨幣我們就真的能廣泛使用數位貨幣，為經濟活動帶來更有效率的流通。</p>

<h2 id="延伸閱讀">延伸閱讀</h2>

<ol>
<li>Blockchain Demo <a href="https://anders.com/blockchain/">https://anders.com/blockchain/</a></li>
<li>區塊鏈 Blockchain — 共識機制之工作量證明 Proof-Of-Work <a href="https://www.samsonhoi.com/360/blockchain_proof_of_work">https://www.samsonhoi.com/360/blockchain_proof_of_work</a></li>
<li>區塊鏈 Blockchain — 創世區塊、區塊、Merkle Tree、Hash <a href="https://www.samsonhoi.com/274/blockchain_genesis_block_merkle_tree">https://www.samsonhoi.com/274/blockchain_genesis_block_merkle_tree</a></li>
<li>比特幣如何達成共識 — 最長鏈的選擇 <a href="https://hk.saowen.com/a/6e038c8f7813d07e59249c2dae9f7064018b50da1604373aa608a61b033a80e1">https://hk.saowen.com/a/6e038c8f7813d07e59249c2dae9f7064018b50da1604373aa608a61b033a80e1</a></li>
</ol>

      </div>
      <p>
        <a href="https://blog.fukuball.com/ethereum-%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98-14blockchain-%E6%8A%80%E8%A1%93%E5%8E%9F%E7%90%86%E7%B0%A1%E4%BB%8B/" class="postShorten-excerpt_link link"></a>
        
      </p>
    </div>
  </div>
  
</article>

          
            
  
    
      
        
      
    
  


  

<article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
  <div class="postShorten-wrap">
    
    <div class="postShorten-header">
      <h1 class="postShorten-title" itemprop="headline">
        <a class="link-unstyled" href="https://blog.fukuball.com/ethereum-%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98%E7%B7%B4%E7%BF%92-1%E4%BD%BF%E7%94%A8-mist-%E7%99%BC%E8%A1%8C%E8%87%AA%E5%B7%B1%E7%9A%84-token/">
          Ethereum 開發筆記練習 1：使用 Mist 發行自己的 Token
        </a>
      </h1>
      
  <div class="postShorten-meta post-meta">
    
      <time itemprop="datePublished" datetime="2018-09-08T11:54:00&#43;08:00">
        
  September 8, 2018

      </time>
    
    
  </div>

    </div>
    <div class="postShorten-excerpt" itemprop="articleBody" style="margin-bottom: 50px;">
      <div class="main-content-wrap">
        <p>之前說過，Blockchain 基本上是因為金流帳本這樣的問題而被創造出來的，也就是說區塊鏈非常適合運用在金流的應用上，我們也可以建立自己的 Blockchain 來搭建自己的金流系統，不過在 Ethereum 上 Smart Contract 這種設計讓我們擁有可以在 Ethereum 區塊鏈上創造自己金流系統的能力，如此我們就不需要自己建一條鏈了。</p>

<p>我們使用 Smart Contract 仿造貨幣性質創造了數位資產（說穿了其實就是在 Smart Contract 上紀錄的變數而已），而這種具貨幣性質的數位資產又被稱作 Token，如此我們就可以在應用程式中使用這個去中心化的金流系統，由於 Token 的應用很普遍，大部分的功能都已經標準化了，我們只要仿造標準來實作就可以發行自己的數位貨幣了。</p>

<p>在這邊我們就練習一下怎麼使用 Mist 發佈 Token Smart Contract 來發行自己的數位貨幣。（目前我們還沒有學習過如何撰寫 Smart Contract，因此這邊會先直接提供範例程式碼，實作的部分我們之後再慢慢學習）</p>

<p>以下是我們的範例程式碼：</p>

<script src="https://gist.github.com/fukuball/cee33c8a16548cf5e17920550b08f7cc.js"></script>

<p>請打開 Mist，如下圖點擊 Contract，然後點擊 Deploy New Contract。</p>

<p style="text-align:center">
    <img src="https://blog.fukuball.com/images/ethereum/ethereum-p1-01.png">
</p>

<p>你會看到如下圖的頁面，請在 Solidity Contract Source Code 中貼上我們上面提供的範例程式碼。</p>

<p style="text-align:center">
    <img src="https://blog.fukuball.com/images/ethereum/ethereum-p1-02.png">
</p>

<p>貼上範例程式碼之後，Mist 會自動編譯程式，檢查是否有語法上的錯誤，如果沒問題，右方的 Select Contract to Deploy 就會出現選項，在這邊我們選擇 Token ERC 20。</p>

<p style="text-align:center">
    <img src="https://blog.fukuball.com/images/ethereum/ethereum-p1-03.png">
</p>

<p>選擇 Token ERC 20 之後，右方會出現要初始化 Contract 的參數表單，有 Initial supply、Token name、Token symbol 需要填寫。Initial supply 代表 Token 的總發行量是多少，我這邊設定成 7777777777，你可以設成你想要的數字。Token name 就是這個 Token 要叫什麼名字，這邊我設定成 7 Token，你想要取 Dog Coin 或是 Cat Coin 也都可以。Token symbol 就是這個 Token 要用什麼代號，像是美金就是用 $、Ether 是用 ETH，這邊我設定成 7token，你可以取自己覺得帥的代號。</p>

<p style="text-align:center">
    <img src="https://blog.fukuball.com/images/ethereum/ethereum-p1-04.png">
</p>

<p>借下來捲動頁面到底下，這邊你可以設定 Gas Fee 要用多少，這邊就看自己高興，我是沒有做任何調整。最後按下 Deploy！</p>

<p style="text-align:center">
    <img src="https://blog.fukuball.com/images/ethereum/ethereum-p1-05.png">
</p>

<p>與區塊鏈互動基本上就是做交易，所以發佈 Smart Contract 也就需要發出一個交易，Mist 會彈出視窗顯示交易資訊及可能的 Gas Fee，請輸入密碼進行交易。</p>

<p style="text-align:center">
    <img src="https://blog.fukuball.com/images/ethereum/ethereum-p1-06.png">
</p>

<p>等待一下子就可以看到我們的 Smart Contract 發佈交易已經出現在頁面底端了，只要等待交易被確認，那一個新的數位貨幣就誕生了！</p>

<p style="text-align:center">
    <img src="https://blog.fukuball.com/images/ethereum/ethereum-p1-07.png">
</p>

<p>Smart Contract 發佈完成後，請點擊你的帳戶，如下圖所示。</p>

<p style="text-align:center">
    <img src="https://blog.fukuball.com/images/ethereum/ethereum-p1-08.png">
</p>

<p>你會發現你的帳戶底下多了一個 Token 紀錄，在這邊我擁有了 7 Token 共 7,777,777,777 顆！如果這個 Token 被承認，那我就是超級有錢人啦！</p>

<p style="text-align:center">
    <img src="https://blog.fukuball.com/images/ethereum/ethereum-p1-09.png">
</p>

<p>接下來我們來實際轉一些 Token 給朋友看看，在區塊鏈的世界我們不需要銀行及任何中心化的系統就可以將錢轉給朋友了，也就是我們現在擁有了一個去中心化的金流系統！讓我們來實際感受一下吧！</p>

<p>請點擊 7 Token 選項右邊的 Send，如下圖所示：</p>

<p style="text-align:center">
    <img src="https://blog.fukuball.com/images/ethereum/ethereum-p1-10.png">
</p>

<p>填入朋友的 Ethereum 帳戶位址到 To 這個欄位，Amount 填入你想要匯出的 Token 數量，在這邊我填 40，然後捲動頁面到底端送出交易。</p>

<p style="text-align:center">
    <img src="https://blog.fukuball.com/images/ethereum/ethereum-p1-11.png">
</p>

<p>等待一下子交易確認後，40 個 Token 就完成匯出了！</p>

<p style="text-align:center">
    <img src="https://blog.fukuball.com/images/ethereum/ethereum-p1-12.png">
</p>

<p>我們可以到 Etherscan上確認交易是否真的完成：<a href="https://ropsten.etherscan.io/address/0xed29cd5a72b06793601da5f0c4ec3ef5224037c7#tokentxns">https://ropsten.etherscan.io/address/0xed29cd5a72b06793601da5f0c4ec3ef5224037c7#tokentxns</a></p>

<p style="text-align:center">
    <img src="https://blog.fukuball.com/images/ethereum/ethereum-p1-13.png">
</p>

<p>的確有 40 個 7 Token 轉到朋友帳戶了！</p>

<p>在這個練習中，我們了解了 Token 到底是什麼，然後我們也實際發行了自己的數位貨幣，完成了自己的去中心化的金流系統，當我們想要轉帳時，我們再也不需要銀行及任何中心化的系統就可以將錢轉給朋友了，只要我們雙方都信任這個數位貨幣，價值的交換就能無遠弗屆地進行了！</p>

      </div>
      <p>
        <a href="https://blog.fukuball.com/ethereum-%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98%E7%B7%B4%E7%BF%92-1%E4%BD%BF%E7%94%A8-mist-%E7%99%BC%E8%A1%8C%E8%87%AA%E5%B7%B1%E7%9A%84-token/" class="postShorten-excerpt_link link"></a>
        
      </p>
    </div>
  </div>
  
</article>

          
            
  
    
      
        
      
    
  


  

<article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
  <div class="postShorten-wrap">
    
    <div class="postShorten-header">
      <h1 class="postShorten-title" itemprop="headline">
        <a class="link-unstyled" href="https://blog.fukuball.com/ethereum-%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98-13%E4%BD%BF%E7%94%A8-mist/">
          Ethereum 開發筆記 1–3：使用 Mist
        </a>
      </h1>
      
  <div class="postShorten-meta post-meta">
    
      <time itemprop="datePublished" datetime="2018-09-07T15:45:00&#43;08:00">
        
  September 7, 2018

      </time>
    
    
  </div>

    </div>
    <div class="postShorten-excerpt" itemprop="articleBody" style="margin-bottom: 50px;">
      <div class="main-content-wrap">
        

<p>Mist 跟前回介紹的 MetaMask 一樣是可以與 Ethereum 進行互動的工具，除了可以管理 Ethereum 相關密鑰之外，Mist 還包含了 Ethereum 節點以及網頁瀏覽器，方便大家瀏覽 Dapp 網頁。</p>

<p>首先請到<a href="https://github.com/ethereum/mist/releases">這邊</a>安裝 Mist，請選擇適於自己的作業系統安裝。</p>

<p style="text-align:center">
    <img src="https://blog.fukuball.com/images/ethereum/ethereum-1-3-01.png">
</p>

<p>由於 Mist 會安裝節點在你的電腦裡，也因此會同步整個帳本下來，所以會花上不少時間同時也會佔用許多硬碟空間。我們目前僅是要使用測試鏈，所以請切換到 Ropsten 測試鏈（如下圖），這樣就不用花這麼多時間與空間了。</p>

<p style="text-align:center">
    <img src="https://blog.fukuball.com/images/ethereum/ethereum-1-3-02.png">
</p>

<p>在 Mist 的左下角可以觀察目前已同步到你的電腦的區塊數（如下圖），如果這個數字跟 <a href="https://ropsten.etherscan.io/">Etherscan</a>（Etherscan 是一個可以查看 Ethereum 區塊鏈所有交易的網站） 上的最新區塊數一致的話，那就代表已經同步完成了。</p>

<p style="text-align:center">
    <img src="https://blog.fukuball.com/images/ethereum/ethereum-1-3-03.png">
</p>

<p>接下來讓我們用 Mist 開一個 Ethereum 帳戶，請點擊 Add Account，並依指示輸入密碼後創建帳號，密碼請務必要記下來，將來交易時都會需要輸入你的密碼。</p>

<p style="text-align:center">
    <img src="https://blog.fukuball.com/images/ethereum/ethereum-1-3-04.png">
</p>

<p>學會創建 Ethereum 帳戶之後，我們要來看一下 Mist 要怎麼備份帳號，請點擊 Mist 上方選單的 File -&gt; Backup -&gt;Accounts（如下圖），這樣就會打開帳號存放的資料夾，所有的帳號都會加密存在這邊，所以只要備份這些檔案及當時設定的密碼，你就可以在別台電腦復原你的帳號。</p>

<p style="text-align:center">
    <img src="https://blog.fukuball.com/images/ethereum/ethereum-1-3-05.png">
</p>

<p>現在你這個 Ethereum 帳戶還沒有任何 Ether，我們仿造之前用 MetaMask 來跟水龍頭要 Ether 的步驟來取得 Ether 看看。</p>

<p>我個人提供了一個水龍頭 Dapp，請前往這個網址來取得 Ether：<a href="https://blog.fukuball.com/dapp/faucet/">https://blog.fukuball.com/dapp/faucet/</a></p>

<p>由於 Mist 也是一個 Dapp 網頁瀏覽器，請在 Mist 上方的網址列輸入：<a href="https://blog.fukuball.com/dapp/faucet/">https://blog.fukuball.com/dapp/faucet/</a></p>

<p style="text-align:center">
    <img src="https://blog.fukuball.com/images/ethereum/ethereum-1-3-06.png">
</p>

<p>Mist 在揭露你的 Ethereum 帳戶資訊給 Dapp 網頁時都會詢問你的同意，請先選擇要瀏覽這個 Dapp 網頁的帳號（你可能在 Mist 有多個帳號，所以就需要選擇目前要用哪個帳號瀏覽這個網頁）。</p>

<p style="text-align:center">
    <img src="https://blog.fukuball.com/images/ethereum/ethereum-1-3-07.png">
</p>

<p>然後點擊 Authorize，這樣就可以連上 Dapp 網頁了。</p>

<p style="text-align:center">
    <img src="https://blog.fukuball.com/images/ethereum/ethereum-1-3-08.png">
</p>

<p>你可以看到跟 MetaMask 一樣，Ethereum 帳號（public address）已經被填寫到 Send To 欄位了，只要按下 Send To 之後不久你就可以從水龍頭收到 Ether 了。</p>

<p style="text-align:center">
    <img src="https://blog.fukuball.com/images/ethereum/ethereum-1-3-09.png">
</p>

<p>果然不久之後我們就收到了 0.5 Ether！</p>

<p style="text-align:center">
    <img src="https://blog.fukuball.com/images/ethereum/ethereum-1-3-10.png">
</p>

<p>接下來我們一樣練習一下把 0.1 Ether 匯回給水龍頭，請在 Credit 欄位輸入 0.1，然後按下 Credit。</p>

<p style="text-align:center">
    <img src="https://blog.fukuball.com/images/ethereum/ethereum-1-3-11.png">
</p>

<p>這時 Mist 跟 MetaMask 一樣會彈出一個視窗顯示 Gas Fee 等資訊，不同的地方是 Mist 需要輸入密碼來授權這個交易。</p>

<p style="text-align:center">
    <img src="https://blog.fukuball.com/images/ethereum/ethereum-1-3-12.png">
</p>

<p>交易進行時，你會收到一個 Tx id，在我這邊的例子是：0x82407e0aac7cc5d3ef485ffba78f279b37aaba50e64396c477b1b19ee5590793，你可以到 Etherscan 去查看這筆交易進行的狀態：<a href="https://ropsten.etherscan.io/tx/0x82407e0aac7cc5d3ef485ffba78f279b37aaba50e64396c477b1b19ee5590793">https://ropsten.etherscan.io/tx/0x82407e0aac7cc5d3ef485ffba78f279b37aaba50e64396c477b1b19ee5590793</a></p>

<p style="text-align:center">
    <img src="https://blog.fukuball.com/images/ethereum/ethereum-1-3-13.png">
</p>

<p>不久之後，等交易確認，你就可以看到 Ether 變成 0.4 了，你成功匯回了 0.1 Ether。</p>

<p style="text-align:center">
    <img src="https://blog.fukuball.com/images/ethereum/ethereum-1-3-14.png">
</p>

<p>如同使用 MetaMask，我們也可以使用官方提供的 Mist 來與 Ethereum 區塊鏈做互動，其實都不錯用，但 Mist 相對肥大很多，也因此有時候交易會卡住，畢竟 Mist 在你的機器上安裝了 Ethereum 節點，所以比起 MetaMask 複雜許多，也比較容易遇到問題。如果你遇到問題了，可能重開 Mist 就能解決，如果還是不能解決，那就 google 吧！</p>

<h2 id="appendix">Appendix</h2>

<p>Mist 在系統背景開了一個叫 geth 的程序，這個 geth 就是主要用來與 Ethereum Network 互動的程式，未來我們會再多說一點 geth，在這邊我們先稍微看一下就好。</p>

<p>請在 Terminal 輸入指令：</p>

<pre><code>ps aux | grep geth
</code></pre>

<p>你會看到 geth 真的有被跑在背景執行：</p>

<p style="text-align:center">
    <img src="https://blog.fukuball.com/images/ethereum/ethereum-1-3-15.png">
</p>

<p>我們也可以進入 geth 的指令介面來使用 geth 更多功能，請在 Terminal 輸入指令：</p>

<pre><code>/Users/username/Library/Application\ Support/Mist/binaries/Geth/unpacked/geth attach ~/Library/Ethereum/geth.ipc
</code></pre>

<p>你會看到像這樣的互動介面：</p>

<p style="text-align:center">
    <img src="https://blog.fukuball.com/images/ethereum/ethereum-1-3-16.png">
</p>

<p>在這邊可以使用 geth 更多與 Ethereum 互動的指令，我們後續會學到更多，在這邊先簡單感受一下就好，你可以輸入指令：</p>

<pre><code>net.peerCount
</code></pre>

<p>這樣 geth 就會回覆目前你的節點有多少的 peer 連結，其他的功能，我們就以後再說吧！</p>

      </div>
      <p>
        <a href="https://blog.fukuball.com/ethereum-%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98-13%E4%BD%BF%E7%94%A8-mist/" class="postShorten-excerpt_link link"></a>
        
      </p>
    </div>
  </div>
  
</article>

          
            
  
    
      
        
      
    
  


  

<article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
  <div class="postShorten-wrap">
    
    <div class="postShorten-header">
      <h1 class="postShorten-title" itemprop="headline">
        <a class="link-unstyled" href="https://blog.fukuball.com/ethereum-%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98-12%E4%BD%BF%E7%94%A8-metamask/">
          Ethereum 開發筆記 1–2：使用 MetaMask
        </a>
      </h1>
      
  <div class="postShorten-meta post-meta">
    
      <time itemprop="datePublished" datetime="2018-09-06T17:46:00&#43;08:00">
        
  September 6, 2018

      </time>
    
    
  </div>

    </div>
    <div class="postShorten-excerpt" itemprop="articleBody" style="margin-bottom: 50px;">
      <div class="main-content-wrap">
        <p>前一回稍微對 Blockchain、Bitcoin、Ethereum 做了一個科普的簡介，我們可以知道 Blockchain 就是一個帳本，每一個加入 Blockchain 的節點都會下載整個帳本在本地端，所以我們就可以在自己的節點（系統）寫入資料到帳本並透過 Blockchain 背後的機制同步到所有的節點。</p>

<p>但實際在節點帳本上寫入交易紀錄前，我們先使用 MetaMask 這個工具來跟 Ethereum 互動吧，不然要裝好 Ethereum 節點、下載好帳本可能會花上不少時間，在這之前就失去耐性的話可不是一個好的開始。</p>

<p style="text-align:center">
    <img src="https://blog.fukuball.com/images/ethereum/ethereum-1-2-01.png">
</p>

<p>MetaMask 這個工具可以讓你不用安裝節點就跟 Ethereum 上的帳本做互動，這背後的原理其實就是使用別人幫忙維護的節點，如此就可以不用自己安裝節點、同步帳本。</p>

<p>首先請到 MetaMask 上安裝 Chrome（或 Firefox）外掛，並請依指示安裝，MetaMask 會創建 Ethereum 帳戶及相關密鑰，MetaMask 也會管理密鑰，讓你可以方便地使用密鑰來與 Ethereum 互動，請記下密碼及 12 個單字的帳戶復原字，這 12 復原字可以用來讓你回復 Ethereum 帳戶，如下圖。</p>

<p style="text-align:center">
    <img style="width: 50%;" src="https://blog.fukuball.com/images/ethereum/ethereum-1-2-02.png">
</p>

<p>Ethereum 上流通的貨幣就是 Ether，它用來當成 Ethereum Blockchain 得以運作的貨幣，Ethereum 上的節點想在 Ethereum 上做運算或是記下資料，那就需要付 Ether 當手續費，而在 Ethereum 上當礦工的節點就可以提供運算資源收取 Ether 當報酬。就如同現實世界一樣，貨幣的流通形成了資源的流通，讓世界可以正常運作。</p>

<p>我們先切換到 Ropsten Test Network（Ethereum 的測試鏈，上面的 Ether 是沒有任何價值的）來感受一下在 Blockchain 上怎麼進行交易。</p>

<p style="text-align:center">
    <img src="https://blog.fukuball.com/images/ethereum/ethereum-1-2-03.png">
</p>

<p>現在我們還沒有任何 Ether 可以使用，這樣我們就沒辦法與 Ethereum 做互動，也就是無法做任何交易，讓我們來跟水龍頭要一些 Ether 來花吧！（在測試鏈上有佛心水龍頭，但正式鏈上就要自己挖礦或是花錢買 Ether 了！）</p>

<p>我個人提供了一個水龍頭 Dapp，請前往這個網址來取得 Ether：<a href="https://blog.fukuball.com/dapp/faucet/">https://blog.fukuball.com/dapp/faucet/</a></p>

<p style="text-align:center">
    <img src="https://blog.fukuball.com/images/ethereum/ethereum-1-2-04.png">
</p>

<p>這個 Dapp 會讀取你的帳戶位址到 Send To 欄位，你也可以自己複製位址到 Send To 欄位，點擊 Send To 之後不久就可以收到 Ether 了！</p>

<p style="text-align:center">
    <img src="https://blog.fukuball.com/images/ethereum/ethereum-1-2-05.png">
</p>

<p>如上圖，我們不久之後就收到了 0.5 Ether，接下來我們來把 0.1 Ether 捐回去給水龍頭提供者看看。</p>

<p style="text-align:center">
    <img src="https://blog.fukuball.com/images/ethereum/ethereum-1-2-06.png">
</p>

<p>請在 Credit 欄位上輸入 0.1，並點擊 Credit。</p>

<p style="text-align:center">
    <img src="https://blog.fukuball.com/images/ethereum/ethereum-1-2-07.png">
</p>

<p>這時 MetaMask 會彈出交易視窗，顯示將要匯出 0.1 Ether（約 22.78 美金），然後手續費 Gas Fee（礦工運算顯）是 0.0001 Ether。（手續費現實世界通用的，但在 Ethereum 的世界叫 Gas Fee，之後文章將都統一使用 Gas Fee）</p>

<p style="text-align:center">
    <img src="https://blog.fukuball.com/images/ethereum/ethereum-1-2-08.png">
</p>

<p>你可以點擊 Edit 調整 Gas Fee，簡易說明下 Gas Fee，Gas Fee 就是 Gas Price（以 Gwei 為單位）X Gas Limit 的計算結果，因此這個例子的 Gas Fee 就是 0.0001 Ether，Gas Price 影響的是礦工運算的優先度，Gas Limit 影響的則是可用多少運算資源。</p>

<p style="text-align:center">
    <img src="https://blog.fukuball.com/images/ethereum/ethereum-1-2-09.png">
</p>

<p>不久之後，我們的 Ether 降到了 0.399978，我們成功地匯回了 0.1 Ether，而 Gas Fee 沒有花完所以得到的 balance 是 0.399978，並非 0.3999（Gas Fee 花光會有交易失敗風險）。</p>

<p>我們成功地透過了 MetaMask 在 Ethereum 上做交易，我們可以不用透過銀行就可以將錢匯來匯去了！只要會寫 Dapp，我們就可以從世界各地賺錢，讓使用者直接與我們交易，中間不需要再接銀行的金流了，這樣的世界是不是很棒呢！</p>

      </div>
      <p>
        <a href="https://blog.fukuball.com/ethereum-%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98-12%E4%BD%BF%E7%94%A8-metamask/" class="postShorten-excerpt_link link"></a>
        
      </p>
    </div>
  </div>
  
</article>

          
            
  
    
      
        
      
    
  


  

<article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
  <div class="postShorten-wrap">
    
    <div class="postShorten-header">
      <h1 class="postShorten-title" itemprop="headline">
        <a class="link-unstyled" href="https://blog.fukuball.com/ethereum-%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98-11blockchain-%E7%B0%A1%E4%BB%8B/">
          Ethereum 開發筆記 1–1：Blockchain 簡介
        </a>
      </h1>
      
  <div class="postShorten-meta post-meta">
    
      <time itemprop="datePublished" datetime="2018-09-06T15:57:23&#43;08:00">
        
  September 6, 2018

      </time>
    
    
  </div>

    </div>
    <div class="postShorten-excerpt" itemprop="articleBody" style="margin-bottom: 50px;">
      <div class="main-content-wrap">
        <p>網際網路發展至今，大家已經很習慣上網使用系統與服務了，這樣普遍存在網路上的系統大部分都是 Client-Server 式的系統，這樣的系統會有自己的內部網路與資料庫，當不同的系統之間要溝通或同步資料的時候，通常會透過 API 這樣的管道來溝通與同步資料，而 API 需要工程師撰寫，並不是在這些系統原生就會有的機制與功能，這就會產生開發成本，也因此不同系統之間的資料交換一直是一個需要被解決的問題。</p>

<p>Blockchain 的特性上，若系統是屬於 Blockchain 上的節點，那麼所有的系統節點就是共享同一份資料，當其中一個系統更改了 Blockchain 上的資料，那這一份更改就會同步到所有的系統。</p>

<p>這樣的特性除了泛用的資料同步分享之外，其實也非常適合使用作為「帳本」（可同步、且不可竄改），Bitcoin 是第一個將這樣帳本特性發揚光大的應用，雖然 Bitcoin 被製造出來時還沒有 Blockchain 這樣的概念，但背後的技術及運用的特性就是現在大家在講的 Blockchain。Blockchain 的思想基本上就是以「帳本」這樣的概念產生的，這個帳本上記錄所有的交易紀錄（也就是資料紀錄），且只能新增紀錄，不能修改或刪除紀錄，所有的紀錄像鏈子一樣結合起來，就像一個 chian of block，並透過加密機制讓鏈結的資料不可被竄改，也因此所有的交易紀錄（也就是資料）被紀錄到帳本之中，那就永遠不會消失。要算帳時只要將個人所擁有的所有交易紀錄進帳與出帳加總起來，就可以得到這個帳戶的結餘。Bitcoin 運用了早已存在的 P2P 運算、共識機制、加密機制、Chain of Block 及 Merkle Tree 整合出了現在大家在說的 Blockchain，而這一切的出發點就是為了製造出一個去中心化的金流系統（資料交換系統）。</p>

<p>Bitcoin 帶來了第一波 Blockchain 革命，第二波 Blockchain 革命就是在 Ethereum 開始的。由於在 Bitcoin 上的交易紀錄只是紀錄資料，假設我們將一個可執行的程式紀錄在 Blockchain 交易紀錄上會發生什麼事呢？</p>

<p>這樣這個程式就可以共享在整個 Blockchain 上，大家都可以在 Blockchain 上運行程式，而程式運行的資料可以在 Blockchain 上存取，讓整個 Blockchain 作為資料庫，這樣的程式就叫做 Smart Contract。這樣將程式放到 Blockchain 上運行的想法帶來了 Ethereum 的成功，如此 Ethereum Blockchain 就成了一個非常龐大的運算平台，讓許多去中心化的應用如雨後春筍地開發出來，讓未來的網路應用充滿了更多想像！</p>

<p>這份筆記將會紀錄在 Ethereum 上開發應用所學習到的知識，作為自己的回憶，也分享給想一起學習的開發者。</p>

      </div>
      <p>
        <a href="https://blog.fukuball.com/ethereum-%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98-11blockchain-%E7%B0%A1%E4%BB%8B/" class="postShorten-excerpt_link link"></a>
        
      </p>
    </div>
  </div>
  
</article>

          
            
  
    
      
        
      
    
  


  

<article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
  <div class="postShorten-wrap">
    
    <div class="postShorten-header">
      <h1 class="postShorten-title" itemprop="headline">
        <a class="link-unstyled" href="https://blog.fukuball.com/ji-yu-lstm-shen-du-xue-xi-fang-fa-yan-fa-er-cheng-de-zhang-yu-sheng-ge-ci-chan-sheng-mo-xing-zhi-jing-zhang-yu-sheng/">
          基於 LSTM 深度學習方法研發而成的張雨生歌詞產生模型，致敬張雨生
        </a>
      </h1>
      
  <div class="postShorten-meta post-meta">
    
      <time itemprop="datePublished" datetime="2018-03-27T08:16:40&#43;08:00">
        
  March 27, 2018

      </time>
    
    
  </div>

    </div>
    <div class="postShorten-excerpt" itemprop="articleBody" style="margin-bottom: 50px;">
      <div class="main-content-wrap">
        

<p>之前看到〈<a href="http://mp.weixin.qq.com/s/uYiq2knJ0rrzdpuvbdmWhw">『致敬赵雷』基于TensorFlow让机器生成赵雷曲风的歌词</a>〉這篇文章覺得非常有趣，因此一直都想自己動手試試看，中國有趙雷，那台灣要找什麼值得紀念的音樂人來作這個歌詞機器學習模型呢？我想<a href="https://zh.wikipedia.org/wiki/%E5%BC%B5%E9%9B%A8%E7%94%9F">張雨生</a>應該會是台灣非常值得令人紀念的音樂人之一了。</p>

<p>程式的基礎我使用了之前在 GitHub 上有點小小貢獻的一個 Project 作為程式碼基礎，這個 Project 是 <a href="https://github.com/hit-computer/char-rnn-tf">char-rnn-tf</a>，可以用於生成一段中文文本（訓練與料是英文時也可以用於生成英文），訓練語料庫我收集了張雨生的百餘首歌詞（包含由張雨生演唱或作曲的歌詞），由於這樣的歌詞語料還是有些不足，因此也加入了林夕、其他著名歌詞、新詩作為輔助，整個語料庫大致包含 74856 個字、2612 個不重複字（其實語料庫還是不足）。</p>

<p>演算法基本上就是 LSTM，細節在此就不多加著墨，若有興趣可以在<a href="https://brohrer.mcknote.com/zh-Hant/how_machine_learning_works/how_rnns_lstm_work.html">這篇文章</a>了解一下，沒有時間的人，也可以看看 char-rnn-tf 這個 Project 作者所做的這張圖（見下圖），對概念了解一下。</p>

<p><img src="https://github.com/hit-computer/char-rnn-tf/blob/master/model.jpg?raw=true" alt="https://github.com/hit-computer/char-rnn-tf/blob/master/model.jpg?raw=true" /></p>

<p>相關程式碼我放在這邊：<a href="https://github.com/fukuball/Tom-Chang-Deep-Lyrics">Tom-Chang-Deep-Lyrics</a>，如何安裝環境、如何訓練、如何生成歌詞，基本上都寫在 Readme 了，大家可以前往瞧瞧。</p>

<hr />

<h3 id="歌詞產生結果">歌詞產生結果</h3>

<h4 id="範例一-夢想">範例一：夢想</h4>

<p>訓練完模型之後（用 macbook air 大致上需要 1 天的時間），由於大眾對張雨生歌詞的印象應該就是「我的未來不是夢」，因此我首先使用「夢想」作為 seed，結果產生歌詞如下：</p>

<pre><code>夢想會有心
我不願再區福　也不是一種把你一樣偷偷
我的心中有無奈

在我的心裡流　你的身影　你的轉身　你的沈靜　框進畫裡印象派的意

我有個朋友聽我說故舊　這一路悠揚的街長
我是天堂飄輝在天空裡
期待愛人看不同的眼睛
我等待與你身邊
你的歡念　你的灑明　在我心底都是飄逸水墨

我想你　愛過了我的一切
為你一起孤定我的美麗
</code></pre>

<p>產生的結果，歌詞機器學習模型先把詞補成句子<strong>「夢想會有心」</strong>，其實補得蠻好的啊！</p>

<p><strong>「我不願再區福　也不是一種把你一樣偷偷 我的心中有無奈」</strong></p>

<p>這邊雖有錯字，但也不至於不能理解。</p>

<p><strong>「在我的心裡流　你的身影　你的轉身　你的沈靜　框進畫裡印象派的意」</strong></p>

<p>這裡則結合了一首新詩，自創了歌詞。&rsquo;</p>

<p><strong>「我有個朋友聽我說故舊　這一路悠揚的街長」</strong></p>

<p>這一句歌詞結合了張雨生的歌曲永公街的街長，說明歌詞機器學習模型的確有張雨生的影子，但悠揚的街長感覺怪怪的 XD</p>

<hr />

<h4 id="範例二-我的未來不是夢">範例二：我的未來不是夢</h4>

<p>從上一個範例，我們可以了解這個歌詞機器學習模型的效果還算不錯，且看起來比起〈<a href="http://mp.weixin.qq.com/s/uYiq2knJ0rrzdpuvbdmWhw">『致敬赵雷』基于TensorFlow让机器生成赵雷曲风的歌词</a>〉這篇所產生的歌詞還要好，仔細看趙雷歌詞產生的結果就會覺得歌詞有點不知所云，而我這邊訓練完的結果，看起來語意會比較明確一些。</p>

<p>接著上個範例，我們來試試看「我的未來不是夢」作為 seed。</p>

<pre><code>我的未來不是夢
我只是真的勇敢

我是一棵秋天的樹　枯少的葉片顯過我
如果有愛能值得這些愁
這個世界保持安靜的距離

熱鬧容易　難得孤寂
我才捨不得問自己
從哪裡來又沒有用　感情和你的歸懷

你是我的姊妹
你是我的 BABY
讓我們的是 BAD BOY　難道我曾經默默縱容　那全是你犯的錯　喔

你贏　我不想與你再爭辯
我說你贏　我再也不想爭辯　請你轉過頭　我有哭泣的尊嚴
我是你的 BABY　我說得再多
</code></pre>

<p><strong>「我的未來不是夢 我只是真的勇敢」</strong></p>

<p>如果少了「只」感覺會更好一些。</p>

<p><strong>「我是一棵秋天的樹　枯少的葉片顯過我 如果有愛能值得這些愁」</strong></p>

<p>這邊則是致敬了張雨生的「我是一棵秋天的樹」的歌詞。</p>

<p><strong>「你是我的姊妹」、「讓我們的是 BAD BOY」、「你贏　我不想與你再爭辯」</strong></p>

<p>這邊則結合了「姊妹」「BAD BOY」「你贏」三首歌詞，有些地方說得通，但其實很難讓整首歌詞語意一致，這是目前這個歌詞機器學習模型需要改善的地方。</p>

<hr />

<h4 id="範例三-永遠不回頭">範例三：永遠不回頭</h4>

<p>接下來試試經典歌曲「永遠不回頭」作為 seed。</p>

<pre><code>永遠不回頭
我只能誠實你只能真摰　你無需幻想你無需作夢

當舞台來喝采聲星　為你的心呢的旋律
我是如此的愛　被我無深在心靈
我的愛沒有書香的清澈　我的愛沒有酒醇的狂語
我的愛沒有鑽石的雨　我是真的 人是假的唯

我要你的愛不曾衰竭　只要越來越不知道那無遲

別用你的眼　用我的心
好好一些感動

我在你心裡面看不見
我的世界裡用天地溫柔
永遠的感覺你和你
</code></pre>

<p><strong>「永遠不回頭 我只能誠實你只能真摰　你無需幻想你無需作夢」</strong></p>

<p>語意上蠻貼切的。</p>

<p><strong>「別用你的眼　用我的心 好好一些感動」</strong></p>

<p><strong>「我在你心裡面看不見 我的世界裡用天地溫柔 永遠的感覺你和你」</strong></p>

<p>這邊看不出是致敬哪首歌詞，比較像是歌詞機器學習模型自己從看過的語料中創作出來的，在字彙這麼少的情況下能夠這樣創作真的很不容易，想想自己小時候寫作文就知道這有多難，機器等於是一天學會作文。</p>

<hr />

<h4 id="範例四-我學會飛翔">範例四：我學會飛翔</h4>

<p>接下來使用「我學會飛翔」作為 seed，這是範例中唯一由張雨生寫的歌詞，其他範例都是合作過的歌曲（雖然也都放在語料庫中），哎呀，真不會選範例！</p>

<pre><code>我學會飛翔
深空之前如何困見　那裡有愛的人
為誰呼喚我　那一天我依稀回來
我們的愛情是迷霧　我總是深彎

我不能相信　何難自己

當風和日麗　陽春三月天
燦爛的心境　醉人的詩篇
或許紅磚上　或許小湖沿
繽紛的足跡　飛揚的笑靨
純潔的性靈　仿如剛清醒
又似蒙蔽　你的輪廓　在汗水中穿梭的角梗
吐著濃濃的煙霧恣任冥思出星
燦爛的陽光溫暖不到這樣的角落
一想到你呀 就讓我快樂
就好比蜻猴呀穿梭梭林　聚成了身邊
</code></pre>

<p><strong>「我們的愛情是迷霧」</strong></p>

<p>這也是歌詞機器學習模型自己創作出來的，覺得蠻厲害的。</p>

<p><strong>「當風和日麗　陽春三月天 燦爛的心境　醉人的詩篇」</strong></p>

<p>這邊的詞有點高水準，所以其實是 Overfitting，抄了張雨生的「三月的天真」這首歌詞。</p>

<hr />

<h4 id="範例五-沒有菸抽的日子">範例五：沒有菸抽的日子</h4>

<p>接下來試試另一首經典歌曲「沒有菸抽的日子」作為 seed。</p>

<pre><code>沒有菸抽的日子 喔

蒼匆的年宴不想留念你的存在
等待那一天鐘
不能說
我不會知道該怎麼做

當秋天葉落　西風來臨後
樹靈的枯枝　曳搖千萬萬　搖積不再有不停　是否不能呼吸
你也能夠 不顧

常常常覺得對自己嗎　難道我真的更好

oh 不醉 就學不會

好男人是不是都躲在家裡
為何身邊六塊肌全對女人沒興趣
有時我真懷疑 纏綿悱惻的劇情
幸福結局 只出現在日劇
女人的心 好比 放大鏡
</code></pre>

<p><strong>「沒有菸抽的日子 喔」</strong></p>

<p><strong>「oh 不醉 就學不會」</strong></p>

<p>這兩句真的喔的很貼切啊！很可惜後面 Overfitting 了～</p>

<hr />

<h4 id="範例六-漂向北方">範例六：漂向北方</h4>

<p>最後我們來試試不是張雨生的歌曲看看，刻意選了近期還蠻紅的歌曲「漂向北方」作為 seed。</p>

<pre><code>漂向北方 別問我家鄉
直到昏景 等到癡邊

我期待　在我的窗中
你給我一個感覺
肯定的愛情
擁有工作我的愛　請我的愛沒有書醇的狂向
直到傻風上煙中深起
你知道我不會猜你

我的笑容隨著煦煦和風 溫暖吹襲一股月色迷濛
我的歌聲衝出節節喉嚨 騷動八方就該天地星座 快同我怒吼

大度能寬容 滄海樂悠悠 誰又不想放下身段快意自由
失意也會有 得意也會有 反正都是生不帶來死不帶走
</code></pre>

<p><strong>「漂向北方 別問我家鄉 直到昏景 等到癡邊」</strong></p>

<p>補完的詞還不錯，「等到癡邊」比較不能理解，但算是有趣的創作吧。</p>

<p><strong>「我期待 在我的窗中 你給我一個感覺 肯定的愛情」</strong></p>

<p>致敬了我期待，感覺真的有在期待的感覺。</p>

<p>後面好像 Overfitting 了張雨生的「門外還有愛」，但整首詞的語意還算一致，算是一個不錯的結果。</p>

<hr />

<p>以上就是這個「基於 LSTM 深度學習方法研發而成的張雨生歌詞產生模型」的實驗結果，產生的詞算是可讀，而且有些還蠻有意思的，比較大的問題是上下文的語意可能會不一致，這樣的問題目前也有很多論文在解了，大體上就是用多層的 LSTM，可以將句子為 level 做 Encode 之後做一層 LSTM，將段落為 level 做 Encode 之後做一層 LSTM，結合原本的字詞 level 的 LSTM 模型，應該就可以做出上下文語意一致的歌詞產生模型了，如果大家有做出來，別忘了分享一下啊！</p>

      </div>
      <p>
        <a href="https://blog.fukuball.com/ji-yu-lstm-shen-du-xue-xi-fang-fa-yan-fa-er-cheng-de-zhang-yu-sheng-ge-ci-chan-sheng-mo-xing-zhi-jing-zhang-yu-sheng/" class="postShorten-excerpt_link link"></a>
        
      </p>
    </div>
  </div>
  
</article>

          
            
  
    
      
        
      
    
  


  

<article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
  <div class="postShorten-wrap">
    
    <div class="postShorten-header">
      <h1 class="postShorten-title" itemprop="headline">
        <a class="link-unstyled" href="https://blog.fukuball.com/lin-xuan-tian-jiao-shou-ji-qi-xue-xi-ji-fa-machine-learning-techniques-di-16-jiang-xue-xi-bi-ji/">
          林軒田教授機器學習技法 Machine Learning Techniques 第 16 講學習筆記
        </a>
      </h1>
      
  <div class="postShorten-meta post-meta">
    
      <time itemprop="datePublished" datetime="2018-02-12T10:24:38&#43;08:00">
        
  February 12, 2018

      </time>
    
    
  </div>

    </div>
    <div class="postShorten-excerpt" itemprop="articleBody" style="margin-bottom: 50px;">
      <div class="main-content-wrap">
        

<h3 id="前言">前言</h3>

<p>本系列部落格文章將分享我在 Coursera 上台灣大學林軒田教授所教授的機器學習技法（Machine Learning Techniques）課程整理成的心得，並對照林教授的投影片作說明。若還沒有閱讀過 <a href="https://blog.fukuball.com/lin-xuan-tian-jiao-shou-ji-qi-xue-xi-ji-fa-machine-learning-techniques-di-15-jiang-xue-xi-bi-ji/">第 15 講</a> 的碼農們，我建議可以先回頭去讀一下再回來喔！</p>

<h3 id="範例原始碼-fukuml-簡單易用的機器學習套件-https-github-com-fukuball-fuku-ml">範例原始碼：<a href="https://github.com/fukuball/fuku-ml">FukuML - 簡單易用的機器學習套件</a></h3>

<p>我在分享機器學習基石課程時，也跟著把每個介紹過的機器學習演算法都實作了一遍，原始碼都放在 <a href="https://github.com/fukuball/fuku-ml">GitHub</a> 上了，所以大家可以去參考看看每個演算法的實作細節，看完原始碼會對課程中的數學式更容易理解。</p>

<p>如果大家對實作沒有興趣，只想知道怎麼使用機器學習演算法，那 <a href="https://github.com/fukuball/fuku-ml">FukuML</a> 絕對會比起其他機器學習套件簡單易用，且方法及變數都會跟林軒田教授的課程類似，有看過課程的話，說不定連文件都不用看就會使用 <a href="https://github.com/fukuball/fuku-ml">FukuML</a> 了。不過我還是有寫 <a href="https://github.com/fukuball/FukuML-Tutorial">Tutorial</a> 啦，之後會不定期更新，讓大家可以容易上手比較重要！</p>

<h3 id="熱身回顧一下">熱身回顧一下</h3>

<p>上一講中我們學到了如何使用矩陣分解方法來解推薦問題，機器學習技法課程也到這邊告一段落了，這一講終將會總結回顧一下我們在機器學習技法中學到的所有機器學習演算法，也許還有許多算法沒有介紹到，但基本概念都可以延伸。</p>

<p style="text-align:center">
    <img src="http://static.obeobe.com/image/blog-image/Machine-Learning-Techniques-16-01.png">
</p>

<h3 id="特徵技巧-kernel">特徵技巧：Kernel</h3>

<p>我們學習到了如何使用 Kernel 來表現資料特徵，使用到 Kernel 技巧的相關演算法如下：</p>

<p style="text-align:center">
    <img src="http://static.obeobe.com/image/blog-image/Machine-Learning-Techniques-16-02.png">
</p>

<h3 id="特徵技巧-aggregation">特徵技巧：Aggregation</h3>

<p>我們也可以使用 Aggregation 方法來結合資料特徵，藉以合成更強大的學習演算法，使用到 Aggregation 技巧的相關演算法如下：</p>

<p style="text-align:center">
    <img src="http://static.obeobe.com/image/blog-image/Machine-Learning-Techniques-16-03.png">
</p>

<h3 id="特徵技巧-extration">特徵技巧：Extration</h3>

<p>我們可以使用 Extration 技巧來取得重要的資料特徵，使用到 Extration 技巧的相關演算法如下：</p>

<p style="text-align:center">
    <img src="http://static.obeobe.com/image/blog-image/Machine-Learning-Techniques-16-04.png">
</p>

<h3 id="特徵技巧-low-dim">特徵技巧：Low-Dim</h3>

<p>我們也會使用降維這個特徵技巧來取得資料的重要特徵，用到降維技巧的相關演算法如下：</p>

<p style="text-align:center">
    <img src="http://static.obeobe.com/image/blog-image/Machine-Learning-Techniques-16-05.png">
</p>

<h3 id="優化技巧-gradient-decent">優化技巧：Gradient Decent</h3>

<p>在類神經網路大量用到了 Gradient Decent 技巧來進行 Error 優化，用到 Gradient Decent 技巧的相關演算法如下：</p>

<p style="text-align:center">
    <img src="http://static.obeobe.com/image/blog-image/Machine-Learning-Techniques-16-06.png">
</p>

<h3 id="優化技巧-equivalent-solution">優化技巧：Equivalent Solution</h3>

<p>在許多困難的問題，我們很難找到優化的方法，我們會使用 Equivalent Solution 找到優化的方法，例如 Dual SVM 我們使用 covex QP、Kernel LogReg 我們用 representer、PCA 我們用 eigenproblem 來解。</p>

<p>未來若需要發展自己的演算法，也可以朝 Equivalent Solution 去想優化方法，只是這可能需要大量的數學推理知識。</p>

<p style="text-align:center">
    <img src="http://static.obeobe.com/image/blog-image/Machine-Learning-Techniques-16-07.png">
</p>

<h3 id="優化技巧-multiple-steps">優化技巧：Multiple Steps</h3>

<p>有一些演算法我們會用 Multiple Steps 來一步一步進行優化，，用到 Multiple Steps 技巧的相關演算法如下：</p>

<p style="text-align:center">
    <img src="http://static.obeobe.com/image/blog-image/Machine-Learning-Techniques-16-08.png">
</p>

<h3 id="過擬似技巧-正規化">過擬似技巧：正規化</h3>

<p>由於演算法的能力越來越強，也因此很容易過擬似（Overfitting），所以我們必須要有方法來避免過擬似，其中一個方式就是正規化，我們大致學過的正規化方法如下：</p>

<p style="text-align:center">
    <img src="http://static.obeobe.com/image/blog-image/Machine-Learning-Techniques-16-09.png">
</p>

<h3 id="過擬似技巧-validation">過擬似技巧：Validation</h3>

<p>另外我們也需要使用 Validation 方法讓我們在訓練過程就可以避免過擬似，在機器學習技法中我們學到的一些演算法有因為演算法特性而發展出來的 Valdation 方法：</p>

<p style="text-align:center">
    <img src="http://static.obeobe.com/image/blog-image/Machine-Learning-Techniques-16-10.png">
</p>

<h3 id="機器學習叢林">機器學習叢林</h3>

<p>林軒田老師在機器學習技法課程的一開始就有放過這樣一張投影片，我們進入的是一個機器學習的叢林，從一開始可能對這投影片的所有演算法都不了解，但在這課程的尾聲我們重新回顧，相信大家多少都已經認識了這個叢林的險惡，也了解這個叢林是個多麽有趣與豐富！</p>

<p style="text-align:center">
    <img src="http://static.obeobe.com/image/blog-image/Machine-Learning-Techniques-16-11.png">
</p>

      </div>
      <p>
        <a href="https://blog.fukuball.com/lin-xuan-tian-jiao-shou-ji-qi-xue-xi-ji-fa-machine-learning-techniques-di-16-jiang-xue-xi-bi-ji/" class="postShorten-excerpt_link link"></a>
        
      </p>
    </div>
  </div>
  
</article>

          
          
  <div class="pagination-bar">
    <ul class="pagination">
      
        
          <li class="pagination-prev">
            <a class="btn btn--default btn--small" href="https://blog.fukuball.com/post/">
              <i class="fa fa-angle-left text-base icon-mr"></i>
              <span></span>
            </a>
          </li>
        
        
          <li class="pagination-next">
            <a class="btn btn--default btn--small" href="https://blog.fukuball.com/post/page/3/">
              <span></span>
              <i class="fa fa-angle-right text-base icon-ml"></i>
            </a>
          </li>
        
      
      <li class="pagination-number"> </li>
    </ul>
  </div>


        </section>
        <footer id="footer" class="main-content-wrap">
  <span class="copyrights">
    &copy; 2020 Fukuball. 
  </span>
</footer>

      </div>
    </div>
    
    <div id="about">
  <div id="about-card">
    <div id="about-btn-close">
      <i class="fa fa-remove"></i>
    </div>
    
      <img id="about-card-picture" src="//www.gravatar.com/avatar/6c910ba730e0acfda9ee450eec9776e6?s=110" alt="" />
    
    <h4 id="about-card-name">Fukuball</h4>
    
      <div id="about-card-bio">我是林志傑，網路上常用的名字是 Fukuball。我使用 PHP 及 Python，對機器學習及區塊鏈技術感到興趣。 <a href="https://www.fukuball.com">https://www.fukuball.com</a></div>
    
    
      <div id="about-card-job">
        <i class="fa fa-briefcase"></i>
        <br/>
        Co-Founder / Head of Engineering at OurSong
      </div>
    
    
      <div id="about-card-location">
        <i class="fa fa-map-marker"></i>
        <br/>
        Taipei, Taiwan
      </div>
    
  </div>
</div>

    <div id="algolia-search-modal" class="modal-container">
  <div class="modal">
    <div class="modal-header">
      <span class="close-button"><i class="fa fa-close"></i></span>
      <a href="https://algolia.com" target="_blank" rel="noopener" class="searchby-algolia text-color-light link-unstyled">
        <span class="searchby-algolia-text text-color-light text-small">by</span>
        <img class="searchby-algolia-logo" src="https://www.algolia.com/static_assets/images/press/downloads/algolia-light.svg">
      </a>
      <i class="search-icon fa fa-search"></i>
      <form id="algolia-search-form">
        <input type="text" id="algolia-search-input" name="search"
          class="form-control input--large search-input" placeholder="" />
      </form>
    </div>
    <div class="modal-body">
      <div class="no-result text-color-light text-center"></div>
      <div class="results">
        
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://blog.fukuball.com/ethereum-%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98-23smart-contract-%E5%88%9D%E6%8E%A2%E5%BE%9E-bytecode-%E5%88%B0-solidity/">
                <h3 class="media-heading">Ethereum 開發筆記 2–3：Smart Contract 初探，從 Bytecode 到 Solidity</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Sep 9, 2018
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather">Ethereum 上的 EVM（Ethereum Virtual Machine）可以執行程式，而 EVM 上的可執行程式基本上是 Bytecode 的形式，所以所謂的 Smart Contract 就是存放在 Ethereum 上的 Bytecode，然後可由 EVM 來執行。
Bytecode Smart Contract 直接用 Bytecode 寫 Smart Contract 我們來嘗試一下直接用 Bytecode 來寫 Smart Contract，以下這段程式碼主要內容是執行運算後，將運算結果存放在 0 這個位置：
PUSH1 0x03 PUSH1 0x05 ADD // 3 + 5 -&gt; 8 PUSH1 0x02 MUL // 8 * 2 -&gt; 16 PUSH1 0x00 SSTORE // 將 16 存到 0 這個位置  這段程式轉成 Bytecode 就是：
0x60 0x03 0x60 0x05 0x01 0x60 0x02 0x02 0x60 0x00 0x55  也就是：</div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://blog.fukuball.com/ethereum-%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98-22geth-%E5%9F%BA%E7%A4%8E%E7%94%A8%E6%B3%95%E5%8F%8A%E6%9E%B6%E8%A8%AD-muti-nodes-%E7%A7%81%E6%9C%89%E9%8F%88/">
                <h3 class="media-heading">Ethereum 開發筆記 2–2：Geth 基礎用法及架設 Muti-Nodes 私有鏈</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Sep 9, 2018
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather">要連上 Ethereum 就需要安裝 Ethereum Node，在這邊我們選擇使用 Geth 來安裝 Ethereum Node，接下來就來一步一步的學學怎麼使用 Geth，甚至如何使用 Geth 來架設自己的 Ethereum 私有鏈。
安裝環境 首先我們在 AWS 上開啟兩台 Ubuntu 虛擬機器，記得開 t2.medium（2 vCPU, 4 GB RAM）這個規格以上才跑得動，硬碟可以開 100 G，Security Group 將 TCP 30303 打開，Ethereum Node 之間是用 30303 這個 port 來溝通的。
接下來使用以下指令安裝 Geth：
$ sudo apt-get install -y software-properties-common $ sudo add-apt-repository -y ppa:ethereum/ethereum $ sudo apt-get update $ sudo apt-get install -y ethereum  兩台虛擬機器都要安裝，應該幾分鐘就可以裝好了。
使用 Main Net 安裝完 Geth 之後，我們就可以透過 Geth 連上 Ethereum Network 了，我們就來連上 Main Net 看看：</div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://blog.fukuball.com/ethereum-%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98-21ethereum-%E9%96%8B%E7%99%BC%E6%95%B4%E9%AB%94%E8%84%88%E7%B5%A1/">
                <h3 class="media-heading">Ethereum 開發筆記 2–1：Ethereum 開發整體脈絡</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Sep 9, 2018
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather">在第一次接觸 Ethereum 應用程式開發時，會發現有各式各樣工具，不知要從何下手，我們用一個圖來說明一下與 Ethereum 互動時的整體脈絡及這之間的工具主要做了什麼事，了解之後自己就可以挑選開發時、甚至使用在產品上時要用什麼適合的工具了。
要在自己的機器接上 Ethereum 首先需要安裝 Ethereum Node，我們之前安裝的 Mist 其實就會在我們的機器上安裝 Ethereum Node 並同步帳本，而像這樣安裝 Node 並同步帳本甚至進行挖礦的軟體有很多，大家可以去選擇適合自己使用的。Mist 其實是將一個叫 geth 的軟體用 GUI 包裝起來，如果是開發者的話，可以選擇直接安裝 geth。
geth 提供了許多 API 指令可以讓我們跟 Ethereum 做互動，但有時下指令並不是那麼親和，所以 geth 提供了 RPC(Remote Procedure Calls) 與 IPC(Inter-process Communications) 兩種方式來與 geth 互動，如果你要在 local 機器連上 geth，那就可以使用 IPC；如果要讓遠端連上 geth，那就使用 RPC，可以開 HTTP 或 Web Socket 兩種方式來讓遠端使用。
以上就是 Ethereum 應用程式開發的基礎環境，接下來跟開發網頁應用程式一樣，Ethereum 應用程式也分成後端與前端，後端程式就是 Smart Contract，前端程式就是 Dapp。Smart Contract 可使用 Solidity 撰寫，目前也有許多其他語言可以撰寫 Smart Contract。Smart Contract 要在 Ethereum 上的 EVM 執行要先 Compile 成 Byte Code 之後，再透過 IPC 或 RPC 發佈到 Ethereum 上。前端程式的 Dapp 可用 Web3 JavaScript 透過 RPC 接上 Ethereum，以及使用網頁應用常用到的 HTML、CSS、JavaScript 製作成使用者互動介面，如此就能執行發佈在 Ethereum 上 Smart Contract 所提供的一些程式功能了。</div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://blog.fukuball.com/ethereum-%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98-18ethereum-%E7%9A%84%E7%8D%8E%E5%8B%B5%E6%A9%9F%E5%88%B6/">
                <h3 class="media-heading">Ethereum 開發筆記 1–8：Ethereum 的獎勵機制</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Sep 9, 2018
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather">Bitcoin 的獎勵機制基本上是挖到新區塊的節點獲得記帳權及獎勵，Ethereum 大體也是遵循這樣的概念，但做了一些調整與變化，讓我們整個脈絡了解一下。
由於 Blockchain 是一種去中心化的系統，所有的礦工（節點）可以同時挖礦（計算合法 hash），彼此獨立運作，所以極有可能出現兩的礦工同時發現不同的滿足條件的區塊，如此就會產生我們之前有提過的分叉（Fork）。
那我們該採用誰的區塊當主鏈呢？我們會先依工作量最大的區塊為主鏈，如果工作量一樣，就看誰先接了子區塊，一般來說只有成了主鏈的區塊才能獲得獎勵。但這樣沒有變成主鏈的區塊之前的算力就都白費了，所以 Ethereum 創造了 Uncle Block（叔塊）這樣的概念，不能成為主鏈的區塊如果後來被收留成為 Uncle Block，那這些沒有成為主鏈的區塊也有機會可以做為 Uncle Block 而獲得獎勵。
這就是 Ethereum 共識機制中的 GHOST（Greedy Heaviest Observed Subtree）協議，Ethereum 會這樣設計的原因，是由於 Ethereum 產生區塊的速度較快，也因此較容易產生分叉，也會使得新區塊較難以在整個網絡傳播，這對於傳播速度較慢的區塊並不公平。且分叉後的區塊可能在幾個區塊之後整併起來，我們會發現裡面的交易可能會與主鏈一致（雖然單獨查看分塊交易內容不同，不過數個區塊整體一起看交易內容就一致了），符合這種條件的分叉區塊我們就會納入主鏈參考，這些區塊就成了所謂的 Uncle Block，這某種角度也是更確認了 Blockchain 上的交易內容一致，因此 Uncle Block 也有貢獻，應該給予獎勵。
以上我們已經了解了 Ethereum 上的區塊大致分成兩種，普通區塊和 Uncle Block，Ethereum 對這兩種區塊的獎勵方式是不同的。我們分別來看一下。
普通區塊獎勵  固定獎勵 5 ETH 區塊內所有的 Gas Fee 如果區塊納入了 Uncle Block，那每包含一個 Uncle Block 可以得到固定獎勵 5 ETH * 1/32，也就是 0.15625 ETH，一個區塊最多隻能包含 2 個 Uncle Block，也因此不會無限延伸，同時又可鼓勵區塊納入 Uncle Block，增加交易內容的一致性。  Uncle Block 獎勵  用公式計算：（Uncle Block 高度 + 8 - 包含此 Uncle Block 的區塊的高度）* 普通區塊固定獎勵 / 8  我們用個實例來看一下獎勵怎麼算。首先我們來看一個普通區塊：https://etherscan.</div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://blog.fukuball.com/ethereum-%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98-17blockchain-%E7%9A%84%E4%B8%80%E4%BA%9B%E9%87%8D%E8%A6%81%E6%80%A7%E8%B3%AA/">
                <h3 class="media-heading">Ethereum 開發筆記 1–7：Blockchain 的一些重要性質</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Sep 9, 2018
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather">我們這邊再次總結一下 Blockchain 中幾點較重要的性質，包含共識機制、不可竄改、經濟激勵三項。
共識機制（Consensus） 在分散式系統中，我們需要有一套用於協同合作的共識機制來組織行動，但有時候系統中的成員可能會出錯或是故意傳送出錯誤的資訊，而使得網路中不同成員對於全體協作的策略得出不同的結論，進而破壞系統的一致性，這就是所謂的拜占庭將軍問題。
拜占庭將軍問題（Byzantine Generals Problem） 拜占庭將軍問題這個故事是這樣的：
 一組拜占庭將軍分別各率領一支軍隊共同圍困一座城市，這個敵人雖不比拜占庭帝國，但也足以抵禦 5 支拜占庭軍隊的同時襲擊。這 10 支軍隊在分開的包圍狀態下，他們任 1 支軍隊單獨進攻都毫無勝算，除非有至少 6 支軍隊（一半以上）同時襲擊才能攻下敵國。他們分散在敵國的四周，依靠通信兵騎馬相互通信來協商進攻意向及進攻時間。困擾這些將軍的問題是，他們不確定他們中是否有叛徒，叛徒可能擅自變更進攻意向或者進攻時間。在這種狀態下，拜占庭將軍們才能保證有多於 6 支軍隊在同一時間一起發起進攻，從而贏取戰鬥？
 上述的故事對映到電腦系統裡，將軍便成了電腦，而通信兵就是通訊系統。叛徒發送前後不一致的進攻提議，被稱為「拜占庭錯誤」，而能夠處理拜占庭錯誤的這種容錯性稱為「Byzantine Fault Tolerance」。Blockchain 上的共識機制通常具有容錯的設計來達成一致性，主要比較常見的共識機制方法有兩個，「工作量證明」以及「股權證明」兩種方法。
工作量證明演算法（Proof of Work, PoW） 中本聰在 Bitcoin 中創造性的引入了「工作量證明」（俗稱挖礦）來解決拜占庭將軍問題，顧名思義，工作量證明就是用來證明你做了一定量的工作，可用工作成果來證明完成相應的工作量。其中的工作技術原理可以看之前這篇文章：Ethereum 開發筆記 1–4：Blockchain 技術原理簡介
由於工作量證明具相當高的計算成本，因此無誘因去偽造，只有遵守協議約定，才能夠回收成本並獲得收益，也因此減少了叛徒的產生，減少拜占庭錯誤。
股權證明演算法（Proof of Stake, PoS） 股權證明的出現，主要是希望取代工作量證明，進而減少「挖礦」的大量運算。它與工作量證明不同地方在於：工作量證明中，大家比的是「算力」（運算能力），透過大量運算得出符合難度的 Hash 值，進而得到獎勵；而在股權證明，大家比拼的是「股權」，「股權」越大的人（節點）越大機會負責產生新區塊，進而得到獎勵。
舉例來說，在股權證明系統中所有擁有股權（此 Blockchain 的數位貨幣）的人都有機會被挑選為產生新區塊（也就是記帳）的人，擁有更多股權的人被選中的機率越大。假這這個系統中共有三個人：Alice 持有 50 股、Bob 持有 30 股、Cathy 持有 20 股，那每次 Alice 被選為記帳人的機率會是 Cathy 的兩倍。所以股權證明會驅使人們購買更多的股權，進而增加獲選為記帳人的機率，以買股權來代替挖礦，同樣需要付出高成本，也因此可以減少叛徒的產生，減少拜占庭錯誤。
不可竄改（Immutability） Blockchain 不可竄改的性質主要來自資料結構及 hash 方式的設計，讓資料的順序緊密鏈結，若從中竄改了某些資料，那之後的鏈結 hash 都會發生錯誤，形成了 Blockchain 不可竄改的特性。</div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://blog.fukuball.com/ethereum-%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98-16blockchain-%E7%9B%B8%E9%97%9C%E7%9A%84%E5%8A%A0%E5%AF%86%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/">
                <h3 class="media-heading">Ethereum 開發筆記 1–6：Blockchain 相關的加密基礎知識</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Sep 9, 2018
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather">Blockchain 裡應用了一些加密技術來保證及驗證交易訊息的正確性，這也更加強了 Blockchain 資料不可竄改的特性。我們來介紹其中比較重要的「公私鑰加密」以及「Merkle Tree」加密樹。
公私鑰加密 公私鑰加密算法是目前資訊通訊安全的基石，它保證了加密訊息不可被破解，相關的加解密原理大家可以參考這兩篇文章：
 RSA算法原理（一）http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html RSA算法原理（二）http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html  加密與解密 公私鑰加密方法是一種非對稱式加密，透過公鑰加密過後的訊息只有私鑰可以解密，也因此只要保護好私鑰就能保證資訊的安全。
現在假設 Alice 要傳一個訊息給 Bob，希望訊息加密過後只有 Bob 可以解密，大概會經過如下步驟：
 Bob 傳他的公鑰給 Alice Alice 使用 Bob 的公鑰加密訊息 Alice 將加密過後的訊息傳給 Bob Bob 用他的私鑰解密訊息  我們這邊使用 openssl 來練習一下加密與解密，首先我們來產生一對公私鑰：
// Create RSA private key $ openssl genrsa -des3 -out rsa-key.pem 2048 // Create public key $ openssl rsa -in rsa-key.pem -outform PEM -pubout -out rsa-key-pub.pem  其中 rsa-key.pem 就是私鑰，rsa-key-pub.pem 為公鑰，私鑰會要求設置密碼，請妥善記下密碼。
我們先用 rsa-key-pub.pem 加密資料：</div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://blog.fukuball.com/ethereum-%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98-15blockchain-%E7%9A%84%E4%B8%80%E4%BA%9B%E5%AE%9A%E7%BE%A9%E8%88%87%E5%90%8D%E8%A9%9E/">
                <h3 class="media-heading">Ethereum 開發筆記 1–5：Blockchain 的一些定義與名詞</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Sep 9, 2018
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather">在 Ethereum 開發筆記 1–4 應該已經將 Blockchain 的技術原理說明得很清楚了，不過如果要向一般大眾簡單說明 Blockchain 是什麼，要怎麼說呢？我會說：Blockchain 就是一個分散式帳本，大家都有一樣的帳本，大家都可一起參與記帳，且記完帳大家的帳本就會自動更新到最新版本，而帳裡的紀錄都會分塊並用密碼按順序鏈結起來，用以驗證帳的正確性，如果中間有人改了資料，那後面的鏈結密碼都會發生錯誤，因此沒有人可以亂改帳，這就是 Blockchain。
但 Blockchain 這個名詞還包含了許多概念與內涵，我們之前說過，Blockchain 是因為分散式去中心化帳本的發展而慢慢產生出來的，這樣慢慢被統稱出來的名詞裡底下也就會包含了許多內涵，很難用三言兩語來說明，所以有一些 Blockchain 相關的定義與名詞我們都可以了解一下，這樣就能更了解 Blockchain。
交易（Transaction） 交易是 Blockchain 帳本中的原子單位，如果將交易再往下拆分就會變得沒有意義，比如下列就是一個交易：
 A 減少了 $10 B 增加了 $9 C 增加了 $1  如果只看 1，我們就會想那減少的 $10 到哪裡去了？所以 1、2、3 一起看才算是一個交易。
Blockchain 是一個分散式帳本（Distributed Ledger） 不像銀行依靠自己的帳本來記帳，Blockchain 提供了可靠的分散式帳本，當銀行之間要進行交易時，會需要一個受信任的第三方來進行銀行之間的交易，這也是為何你在做跨國轉帳時，需要付出高昂的手續費以及等待數天處理交易，Blockchain 可靠的分散式帳本讓跨國交易可以在幾分鐘甚至幾秒之內完成，這也是為何銀行想要應用 Blockchain 在金融交易上以降低交易成本。
Blockchain 是一個資料結構（Data Structure） 通常 Blockchain 的資料結構如下組成：
 交易是原子單位 區塊是由一系列的交易組成 區塊鏈由排序良好的區塊所組成  Blockchain 會有分叉（Fork） 當有兩名礦工 A 及 B 幾乎在相同時間內算出了合法的 hash，這兩個區塊傳播到鄰近節點時，有些節點收到了 A 的區塊，有些節點收到了 B 的區塊，這兩個區塊都可以是主鏈的延伸，這時就會產生區塊鏈分叉。</div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://blog.fukuball.com/ethereum-%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98-14blockchain-%E6%8A%80%E8%A1%93%E5%8E%9F%E7%90%86%E7%B0%A1%E4%BB%8B/">
                <h3 class="media-heading">Ethereum 開發筆記 1–4：Blockchain 技術原理簡介</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Sep 9, 2018
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather">之前我們簡單地介紹過 Blockchain 了，但我們還是對 Blockchain 背後的技術原理不是那麼了解，我們知道 Blockchain 是因為一個數位貨幣帳本這樣的概念被創造出來的，而數位貨幣最擔心的是什麼問題呢？其實就是雙重支付（Double-Spending）這樣的問題。
數位貨幣不像實體貨幣，數位資產比起實體資產容易複製，也因此如果花用數位貨幣的行為如果沒有處理好，就會產生憑空多出其他交易，這就像是偽鈔一樣，會造成通貨膨脹而導致貨幣貶值，讓人不再信任並願意持與流通。因此數位貨幣的支付通常需要一個受信任的第三方來做驗證，這樣的做法雖然簡單，卻存在單點脆弱性，只要這第三方受到攻擊或是監守自盜也一樣會讓這個數位貨幣變成一個失敗的貨幣。
分散式去中心化帳本能解決單點脆弱性的問題，但在驗證正確性這點難度卻很高，所有的節點都有記帳的權利，要如何確定由誰來記帳、記的帳對不對？如果無法確定帳是對的，那就存在雙重支付的風險。
為了改善單點脆弱性及雙重支付這樣的問題，許多分散式的雙重支付防範方法慢慢被提出來，中本聰提出了去中心化（以受信任第三方為中心）的方法來展示解決雙重支付問題，並實作出了 Bitcoin，使用共識機制來解決記帳及驗證的問題，這帶來去中心化數位貨幣帳本的成功。
Bitcoin 的共識協議主要由「工作量證明」（Proof-of-Work, PoW）和「最長鏈機制」兩部分組成，Bitcoin 上的各個節點就是透過共識機制中的工作量證明來決定誰有記帳權，然後取得記帳權的節點就能將新的區塊記帳加到最長鏈上並給予該節點獎勵（新區塊獎勵及交易費收益）。
Bitcoin 的 工作量證明大概會做以下的事情：
 收集還未記到帳上的交易 檢查每個交易中付款地址有沒有足夠的餘額 驗證交易是否有正確的簽名 把驗證通過的交易信息進行打包（組成 Merkle Tree） 為自己增加一個交易紀錄獲得 Bitcoin 獎勵金 計算合法的 hash 爭奪記帳權  計算合法 hash 的方式請見下方影片說明，個人覺得這個影片是目前將 Blockchain 加密機制說明得最清楚的影片。我這邊簡略說明一下，合法的 hash 公式大致看起來像這樣：hash(交易內容+交易簽名+nonce+上一個區塊的 hash)，我們要取得記帳權，就需要找出前面開頭有 N 個 0 的 hash，由於交易內容、交易簽名及上一個區塊的 hash 都是不可變的，所以每個節點就是不斷的調整 nonce 來計算得出不同的 hash，直到找到開頭 N 個 0 的 hash 為止，第一個找的節點就能獲得記帳權，而其他的節點只要計算 hash 對不對就能驗證這個帳對不對。其中 N 個 0 開頭的 hash 就代表了計算的難度，越多 0 代表越難找到這樣的 hash，也因此可以調整計算難度。就是這樣的設計解決了去中心化分散式系統驗證資料及決定記帳順序的難題，也就改善了數位貨幣單點脆弱性及雙重支付的問題。
  以上的內容看完應該就能大體了解 Blockchain 的原理了，甚至要自己做一個 Blockchain 都沒問題！了解了 Blockchain 的技術原理之後，應該能更信任去中心化的數位貨幣的安全性，或許有天大家都信任了去中心化的數位貨幣我們就真的能廣泛使用數位貨幣，為經濟活動帶來更有效率的流通。</div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://blog.fukuball.com/ethereum-%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98%E7%B7%B4%E7%BF%92-1%E4%BD%BF%E7%94%A8-mist-%E7%99%BC%E8%A1%8C%E8%87%AA%E5%B7%B1%E7%9A%84-token/">
                <h3 class="media-heading">Ethereum 開發筆記練習 1：使用 Mist 發行自己的 Token</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Sep 9, 2018
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather">之前說過，Blockchain 基本上是因為金流帳本這樣的問題而被創造出來的，也就是說區塊鏈非常適合運用在金流的應用上，我們也可以建立自己的 Blockchain 來搭建自己的金流系統，不過在 Ethereum 上 Smart Contract 這種設計讓我們擁有可以在 Ethereum 區塊鏈上創造自己金流系統的能力，如此我們就不需要自己建一條鏈了。
我們使用 Smart Contract 仿造貨幣性質創造了數位資產（說穿了其實就是在 Smart Contract 上紀錄的變數而已），而這種具貨幣性質的數位資產又被稱作 Token，如此我們就可以在應用程式中使用這個去中心化的金流系統，由於 Token 的應用很普遍，大部分的功能都已經標準化了，我們只要仿造標準來實作就可以發行自己的數位貨幣了。
在這邊我們就練習一下怎麼使用 Mist 發佈 Token Smart Contract 來發行自己的數位貨幣。（目前我們還沒有學習過如何撰寫 Smart Contract，因此這邊會先直接提供範例程式碼，實作的部分我們之後再慢慢學習）
以下是我們的範例程式碼：
 請打開 Mist，如下圖點擊 Contract，然後點擊 Deploy New Contract。
你會看到如下圖的頁面，請在 Solidity Contract Source Code 中貼上我們上面提供的範例程式碼。
貼上範例程式碼之後，Mist 會自動編譯程式，檢查是否有語法上的錯誤，如果沒問題，右方的 Select Contract to Deploy 就會出現選項，在這邊我們選擇 Token ERC 20。
選擇 Token ERC 20 之後，右方會出現要初始化 Contract 的參數表單，有 Initial supply、Token name、Token symbol 需要填寫。Initial supply 代表 Token 的總發行量是多少，我這邊設定成 7777777777，你可以設成你想要的數字。Token name 就是這個 Token 要叫什麼名字，這邊我設定成 7 Token，你想要取 Dog Coin 或是 Cat Coin 也都可以。Token symbol 就是這個 Token 要用什麼代號，像是美金就是用 $、Ether 是用 ETH，這邊我設定成 7token，你可以取自己覺得帥的代號。</div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://blog.fukuball.com/ethereum-%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98-13%E4%BD%BF%E7%94%A8-mist/">
                <h3 class="media-heading">Ethereum 開發筆記 1–3：使用 Mist</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Sep 9, 2018
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather">Mist 跟前回介紹的 MetaMask 一樣是可以與 Ethereum 進行互動的工具，除了可以管理 Ethereum 相關密鑰之外，Mist 還包含了 Ethereum 節點以及網頁瀏覽器，方便大家瀏覽 Dapp 網頁。
首先請到這邊安裝 Mist，請選擇適於自己的作業系統安裝。
由於 Mist 會安裝節點在你的電腦裡，也因此會同步整個帳本下來，所以會花上不少時間同時也會佔用許多硬碟空間。我們目前僅是要使用測試鏈，所以請切換到 Ropsten 測試鏈（如下圖），這樣就不用花這麼多時間與空間了。
在 Mist 的左下角可以觀察目前已同步到你的電腦的區塊數（如下圖），如果這個數字跟 Etherscan（Etherscan 是一個可以查看 Ethereum 區塊鏈所有交易的網站） 上的最新區塊數一致的話，那就代表已經同步完成了。
接下來讓我們用 Mist 開一個 Ethereum 帳戶，請點擊 Add Account，並依指示輸入密碼後創建帳號，密碼請務必要記下來，將來交易時都會需要輸入你的密碼。
學會創建 Ethereum 帳戶之後，我們要來看一下 Mist 要怎麼備份帳號，請點擊 Mist 上方選單的 File -&gt; Backup -&gt;Accounts（如下圖），這樣就會打開帳號存放的資料夾，所有的帳號都會加密存在這邊，所以只要備份這些檔案及當時設定的密碼，你就可以在別台電腦復原你的帳號。
現在你這個 Ethereum 帳戶還沒有任何 Ether，我們仿造之前用 MetaMask 來跟水龍頭要 Ether 的步驟來取得 Ether 看看。
我個人提供了一個水龍頭 Dapp，請前往這個網址來取得 Ether：https://blog.fukuball.com/dapp/faucet/
由於 Mist 也是一個 Dapp 網頁瀏覽器，請在 Mist 上方的網址列輸入：https://blog.fukuball.com/dapp/faucet/
Mist 在揭露你的 Ethereum 帳戶資訊給 Dapp 網頁時都會詢問你的同意，請先選擇要瀏覽這個 Dapp 網頁的帳號（你可能在 Mist 有多個帳號，所以就需要選擇目前要用哪個帳號瀏覽這個網頁）。</div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
      </div>
    </div>
    <div class="modal-footer">
      <p class="results-count text-medium"
         data-message-zero=""
         data-message-one=""
         data-message-other="">
         76 posts found
      </p>
    </div>
  </div>
</div>
    
  
    
    <div id="cover" style="background-image:url('https://blog.fukuball.com/images/ok.jpg');"></div>
  


    
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js" integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=" crossorigin="anonymous"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.7/js/jquery.fancybox.min.js" integrity="sha256-GEAnjcTqVP+vBp3SSc8bEDQqvWAZMiHyUSIorrWwH50=" crossorigin="anonymous"></script>


<script src="https://blog.fukuball.com/js/script-qi9wbxp2ya2j6p7wx1i6tgavftewndznf4v0hy2gvivk1rxgc3lm7njqb6bz.min.js"></script>






<script async src="https://www.googletagmanager.com/gtag/js?id=UA-41911929-4"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-41911929-4');
</script>

    
  </body>
</html>

